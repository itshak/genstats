#ifndef TYPES_H_INCLUDED 
#define TYPES_H_INCLUDED

#include <cassert>
#include <cctype>
#include <climits>
#include <cstdlib>
#include <stdint.h>

typedef uint16_t Themes;
typedef uint32_t Bonuses;
typedef uint32_t Penalties;
typedef uint8_t Transforms;

#define THEMES_MAX 1024
#define BONUSES_MAX 131072
#define PENALTIES_MAX 262144

enum PieceType {
  NO_PIECE_TYPE, PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING,
  ALL_PIECES = 0,
  PIECE_TYPE_NB = 8
};

enum Piece {
  NO_PIECE,
  W_PAWN = 1, W_KNIGHT, W_BISHOP, W_ROOK, W_QUEEN, W_KING,
  B_PAWN = 9, B_KNIGHT, B_BISHOP, B_ROOK, B_QUEEN, B_KING,
  PIECE_NB = 16
};

enum Color {
  WHITE, BLACK, NO_COLOR, COLOR_NB = 2
};

enum Square {
  SQ_A1, SQ_B1, SQ_C1, SQ_D1, SQ_E1, SQ_F1, SQ_G1, SQ_H1,
  SQ_A2, SQ_B2, SQ_C2, SQ_D2, SQ_E2, SQ_F2, SQ_G2, SQ_H2,
  SQ_A3, SQ_B3, SQ_C3, SQ_D3, SQ_E3, SQ_F3, SQ_G3, SQ_H3,
  SQ_A4, SQ_B4, SQ_C4, SQ_D4, SQ_E4, SQ_F4, SQ_G4, SQ_H4,
  SQ_A5, SQ_B5, SQ_C5, SQ_D5, SQ_E5, SQ_F5, SQ_G5, SQ_H5,
  SQ_A6, SQ_B6, SQ_C6, SQ_D6, SQ_E6, SQ_F6, SQ_G6, SQ_H6,
  SQ_A7, SQ_B7, SQ_C7, SQ_D7, SQ_E7, SQ_F7, SQ_G7, SQ_H7,
  SQ_A8, SQ_B8, SQ_C8, SQ_D8, SQ_E8, SQ_F8, SQ_G8, SQ_H8,
  SQ_NONE,

  SQUARE_NB = 64,
};

enum File {
  FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H, FILE_NB
};

enum Rank {
  RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8, RANK_NB
};

enum Theme {
    THEME_NONE = 0, SCRATCH = THEME_NONE,
    GRIMSHAW, // 1   
    PICKANINNY, // 2
    MULTIVAR_THEME_NB, //themes with more then 1 variant
    
    DIRECT_BATTERY = MULTIVAR_THEME_NB, // 3
    //INDIRECT_BATTERY,
    SELF_PINNING, // 4
    UNPIN, // 5
    DATA_NB, //theme with additional data required to detection

    SELF_BLOCKING = DATA_NB, // 6
    KING_MATE,
    VARIANT_THEME_NB, //themes with variants
    
    KING_FLIGHTS = KING_MATE, // 7
    LONELY_KING = VARIANT_THEME_NB, // 8
    TEMPO, // 9
    HALF_PINNING, // 10
    THEME_NB,

    // Special cases for evaluation functions (return them inside in LVL1)
    THREATENED_MATE=THEME_NB,   
    NON_SINGLE,
    EXT_THEME_NB
};

enum Bonus {
    NO_BONUS,
    BONUS_1, BONUS_2, BONUS_3, BONUS_4, BONUS_5, BONUS_6,  BONUS_7, BONUS_8, BONUS_9,
    BONUS_10, BONUS_11, BONUS_13, BONUS_14, BONUS_15, BONUS_16, BONUS_17, BONUS_18,
    BONUS_NB
};

enum Penalty {
    NO_PENALTY,
    PENALTY_1MIN, PENALTY_1MAJ, PENALTY_2MIN, PENALTY_2MAJ, PENALTY_3MIN, PENALTY_3MAJ,
    PENALTY_4, PENALTY_5, PENALTY_6, PENALTY_7, PENALTY_8, PENALTY_9, PENALTY_10,
    PENALTY_11, PENALTY_12, PENALTY_13, PENALTY_14, PENALTY_15,
    PENALTY_NB
};

enum ComposType {
    CREATED, // compositions generated by composgen using piece statistics
    
    DEL_IMP, // generated compositions improved by DEL only
    ADM_IMP, // generated composition improved by ADD, DEL and MOV
    FULL_IMP // generated compositions first improved by DEL only and than by ADM
};

enum TransformType {
    NO_TRANSFORM, ADD, DEL, MOV, TRANSFORMTYPES_NB
};


#define ENABLE_SAFE_OPERATORS_ON(T)                                         \
inline T operator+(const T d1, const T d2) { return T(int(d1) + int(d2)); } \
inline T operator-(const T d1, const T d2) { return T(int(d1) - int(d2)); } \
inline T operator*(int i, const T d) { return T(i * int(d)); }              \
inline T operator*(const T d, int i) { return T(int(d) * i); }              \
inline T operator-(const T d) { return T(-int(d)); }                        \
inline T& operator+=(T& d1, const T d2) { return d1 = d1 + d2; }            \
inline T& operator-=(T& d1, const T d2) { return d1 = d1 - d2; }            \
inline T& operator*=(T& d, int i) { return d = T(int(d) * i); }

#define ENABLE_OPERATORS_ON(T) ENABLE_SAFE_OPERATORS_ON(T)                  \
inline T& operator++(T& d) { return d = T(int(d) + 1); }                    \
inline T& operator--(T& d) { return d = T(int(d) - 1); }                    \
inline T operator/(const T d, int i) { return T(int(d) / i); }              \
inline T& operator/=(T& d, int i) { return d = T(int(d) / i); }

ENABLE_OPERATORS_ON(PieceType)
ENABLE_OPERATORS_ON(Piece)
ENABLE_OPERATORS_ON(Color)
ENABLE_OPERATORS_ON(Square)
ENABLE_OPERATORS_ON(File)
ENABLE_OPERATORS_ON(Rank)
ENABLE_OPERATORS_ON(Theme)
ENABLE_OPERATORS_ON(Bonus)
ENABLE_OPERATORS_ON(Penalty)

/// Added operators for adding integers to a Value. PieceType and Color
inline PieceType operator+(PieceType pt, int i) { return PieceType(int(pt) + i); }
inline PieceType operator-(PieceType pt, int i) { return PieceType(int(pt) - i); }

inline Color operator+(Color c, int i) { return Color(int(c) + i); }
inline Color operator-(Color c, int i) { return Color(int(c) - i); }

#undef ENABLE_OPERATORS_ON
#undef ENABLE_SAFE_OPERATORS_ON

inline Color operator~(Color c) {
  return Color(c ^ BLACK);
}

inline Square operator~(Square s) {
  return Square(s ^ SQ_A8); // Vertical flip SQ_A1 -> SQ_A8
}

inline Square operator|(File f, Rank r) {
  return Square((r << 3) | f);
}

inline Piece make_piece(Color c, PieceType pt) {
  return Piece((c << 3) | pt);
}

inline PieceType type_of(Piece p)  {
  return PieceType(p & 7);
}

inline Color color_of(Piece p) {
  assert(p != NO_PIECE);
  return Color(p >> 3);
}

inline bool is_ok(Square s) {
  return s >= SQ_A1 && s <= SQ_H8;
}

inline File file_of(Square s) {
  return File(s & 7);
}

inline Rank rank_of(Square s) {
  return Rank(s >> 3);
}

inline Square relative_square(Color c, Square s) {
  return Square(s ^ (c * 56));
}

inline Rank relative_rank(Color c, Rank r) {
  return Rank(r ^ (c * 7));
}

inline Rank relative_rank(Color c, Square s) {
  return relative_rank(c, rank_of(s));
}

inline bool opposite_colors(Square s1, Square s2) {
  int s = int(s1) ^ int(s2);
  return ((s >> 3) ^ s) & 1;
}

inline char file_to_char(File f, bool tolower = true) {
  return char(f - FILE_A + (tolower ? 'a' : 'A'));
}

inline char rank_to_char(Rank r) {
  return char(r - RANK_1 + '1');
}


inline TransformType type_of(Transforms t, int level) {
  return TransformType((t >> 2*level) & 0x3);
}

inline void set_transform(Transforms& t, int level, TransformType tt) {
  assert(type_of(t,level) == NO_TRANSFORM);
  t |= Transforms(tt) << 2*level;
}

inline Transforms create_transform(Transforms t, int level, TransformType tt) {
  assert(type_of(t,level) == NO_TRANSFORM);
  return t | (Transforms(tt) << 2*level);
}

// check that there are no NO_TRANSFORMS between not-NO_TRANSFORMs
inline bool is_ok(Transforms t) {
  return type_of(t,0)?
            type_of(t,1)?
                type_of(t,2)?
                    true : t>>4?
                        false : true

              : t>>2?              
                  false : true
          : t?
              false : true;           
}

#include <string>

inline const std::string square_to_string(Square s) {
  char ch[] = { file_to_char(file_of(s)), rank_to_char(rank_of(s)), 0 };
  return ch;
}

static std::string PieceStr[PIECE_NB] =
{
    "NO_PIECE",
    "W_PAWN", "W_KNIGHT", "W_BISHOP", "W_ROOK", "W_QUEEN", "W_KING",
    "NO_PIECE", "NO_PIECE",
    "B_PAWN", "B_KNIGHT", "B_BISHOP", "B_ROOK", "B_QUEEN", "B_KING"
};

static std::string ColorStr[COLOR_NB] =
{
    "WHITE",
    "BLACK"
};

static std::string SquareStr[SQUARE_NB] =
{
    "A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1",
    "A2", "B2", "C2", "D2", "E2", "F2", "G2", "H2",
    "A3", "B3", "C3", "D3", "E3", "F3", "G3", "H3",
    "A4", "B4", "C4", "D4", "E4", "F4", "G4", "H4",
    "A5", "B5", "C5", "D5", "E5", "F5", "G5", "H5",
    "A6", "B6", "C6", "D6", "E6", "F6", "G6", "H6",
    "A7", "B7", "C7", "D7", "E7", "F7", "G7", "H7",
    "A8", "B8", "C8", "D8", "E8", "F8", "G8", "H8"
};

static std::string AmountStr[9] =
{
    "ZERO", "ONE", "TWO", "THREE", "FOUR",
    "FIVE", "SIX", "SEVEN", "EIGHT"
};


static std::string TransformTypeStr[TRANSFORMTYPES_NB] =
{
    "NONE", "ADD", "DEL", "MOV"
};

#include<sqlite3.h>

typedef int (*sqlite3_callback)(
    void*,    /* Data provided in the 4th argument of sqlite3_exec() */
    int,      /* The number of columns in row */
    char**,   /* An array of strings representing fields in the row */
    char**    /* An array of strings representing column names */
);

#endif // #ifndef TYPES_H_INCLUDED
